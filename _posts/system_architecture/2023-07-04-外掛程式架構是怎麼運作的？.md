---
layout: post
title: 外掛程式是怎麼運作的？
description: >
  外掛程式是怎麼運作的？ 我要怎麼實做一個外掛程式架構？
hide_description: true
sitemap: false
image:
    path: https://megacephalo.github.io/megacephalo_tech_blog/assets/img/posts/system_architecture/plugin_archittecture/pexels-karolina-grabowska-6720x4480.jpg
    secret:
        1x: https://megacephalo.github.io/megacephalo_tech_blog/assets/img/posts/system_architecture/plugin_archittecture/pexels-karolina-grabowska-640x427.jpg
        2x: https://megacephalo.github.io/megacephalo_tech_blog/assets/img/posts/system_architecture/plugin_archittecture/pexels-karolina-grabowska-1280x853.jpg
        3x: https://megacephalo.github.io/megacephalo_tech_blog/assets/img/posts/system_architecture/plugin_archittecture/pexels-karolina-grabowska-1920x1280.jpg
hide_last_modified: true
---
你是否曾經想過模組是如何開發並添加到電玩中的？你是否也曾經好奇，為什麼有這麼多專有和開源軟體允許他們的用戶自行添加或刪除插件？我也曾問過同樣的問題。幸運的是，我有機會**透過實現一個點雲處理流程**來更家裡姐這個架構的實做以及使用中體驗到的好與壞。我希望這個點雲圖的處理流程可以讓處理點雲的每一步都可以被視作各別的外掛（插件或微內核）。實際上，一些受歡迎的軟體的設計就是僅僅包括一個核心和多個插件組成設計的。不好意思，由於我不確定我的華文讀者來自何方，所以本篇中的 Plugin 我會稱之為「外掛」或「插件」，希望不會造成讀者的理解困擾。

# 外掛架構的幾個優點

- 開發靈活性
- 使用上的彈性
- 可擴展性
- 模塊化

# 外掛架構的缺點

- 會讓軟體開發稍微複雜一些
- 每個插件都在其自己的執行緒(線程)上運行，通常可能是跑一個 run() 或 execute() 類別方法或函式。實際上，我認為這取決於你想要如何表達程式的特性。
- 程式核心部份的改變可能會破壞掉外掛程式的正常運作，例如這個真實案例：[Subnautica Live At Large Udate Broken mods after the update.](https://steamcommunity.com/app/264710/discussions/0/3730700312409631960/)

# 別光說不練了。寫扣吧！

是的，現在我們來實做一個簡單的外掛架構程式。假設我只想實做兩個外掛，我讓它們都來自同一個外掛基礎類別，雖然限制外掛被呼叫的方式，但除此之外它們有絕對自由的表達方式（還真是詩意~）。在這裡，我使用C++以利用多型的特性，我相信你可以在其他的OOP語言中找到類似的特性，唯一的區別可能只差在某種語言從構建好的程式庫或模塊中讀取動態記憶體時的方式而已。說到這裡，我將不可避免地解釋在C++中實現外掛架構的方式。

在我們深入討論之前，容我官宣一下。這篇的完整實作原始碼可以在我的 GitHub 專案頁[plugin_architecture_practice](https://github.com/Megacephalo/plugin_architecture_practice)中找到。

# 整個程式的架構

核心只包括一個主函數，用於處理插件的調用和關閉。對於實際應用，你可以調整核心在這種架構中的角色，可以讓核心幾乎控制大部分的業務邏輯，或者完全相反，採取"最好的API就是沒有API"的原則，讓所有的特性都作為插件實現和運行。

請參考圖1以查看基本程序的類別圖。

![Fig 1. 外掛的類別圖](https://megacephalo.github.io/megacephalo_tech_blog/assets/img/posts/system_architecture/plugin_archittecture/plugin_architecture_barebone.png)
*圖1. 靜態類別圖顯示插件和PluginInterface類別的繼承關係*

看起來像是一個普通的繼承。但我們如何實現這種結構，使其成為實際運行的插件呢？

## 來實做吧！

我們先來實做外掛基礎類別和關鍵的方法函式。

### 外掛基礎類別

**include/plugin_interface.h**
```C++
#ifndef _PLUGIN_INTERFACE_H_
#define _PLUGIN_INTERFACE_H_

#include <iostream>
#include <memory>
#include <functional>

class PluginInterface {
public:
    virtual ~PluginInterface() {}
    virtual void run() = 0;
};

extern "C" {
    using createPlugin_t = std::shared_ptr<PluginInterface> (*)();
}

#endif /* _PLUGIN_INTERFACE_H_ */

```

在PluginInterface類別中，我們遵循「優良的開發傳統」，加入了一個虛擬解構子，以便從基礎類別創建的衍生類別指標可以有秩序得被正確地一一刪除避免可能的內存洩漏。

這裡有一個抽象虛擬方法以用來執行插件，這個方法也是插件的業務邏輯所在的地方，對於我們的程序中任何插件的運作都是至關重要的。

extern "C" 告訴C++ 編譯器使用C風格的連結方式對大括號之間的代碼進行連結。在C++中，你可以有同名的函數，但接收的類型和參數數量不同。然而，在C語言中剛好相反。當你從共享庫中動態加載函數時（我們將在稍後看到如何做到這一點），你需要將函數名稱作為字符串「調用」。在C++中使用多載的情況下這不太可能做到，因為編譯器會把同名的函數搞混以支援函數重載。通過使用extern "C"，你刻意告訴了編譯器不要對函數名進行多載，所以它可以根據名稱加載對應的函數。

那大括號內的這一行是什麼呢？這就是插件實際被實例化或創建的地方。為了充分利用現代C++的智能指標，我用shared_ptr替換了C風格的指標，不過你可以使用任何你喜歡的指標類型。該指標創建一個函數指標，需要引入()運算子來讓魔法發生（嘿嘿～）。你等一下會看到如何施展這個魔法。

## 開外掛啦！

我只會展示一個外掛的實現，但其他插件應該遵循同樣的方式實做出來。

首先，讓我們撰寫我們的標頭檔。

**include/plugin_1/plugin_1.h**
```C++
#ifndef _PLUGIN_1_H_
#define _PLUGIN_1_H_

#include "plugin_interface.h"

class Plugin1 : public PluginInterface {
  public:
    Plugin1() = default;
    void run() override;

};

extern "C" {
    std::unique_ptr<PluginInterface> createPlugin() {
        return std::make_unique<Plugin1>();
    }
}

#endif /* _PLUGIN_1_H_ */
```

這些都是常見的東西，但請注意在extern "C"大括號內的行。這幾行實際上與PluginInterface類別中的不同。這邊你將按名稱調用的函數（還記得我們在前面部分對extern "C"的長篇解釋嗎？）為什麼這是指向基礎類別的指標呢？因為我們將使用此函數返回的實例重載基礎函數。因此，我們手頭上已經湊齊了所有的拼圖。

## 勿忘程式核心！

我將展示一種讓插件並行的方式。如果不調用執行緒，你會看到每個插件將依序而非並行運作。

**application/main.cpp**

```C++
#include <iostream>
#include <string>
#include <memory>
#include <filesystem>
#include <thread>
#include <vector>
#include <dlfcn.h>
#include <functional>

#include "plugin_interface.h"
#include "plugin_1/plugin_1.h"

std::unique_ptr<PluginInterface> loadPlugin(const std::string& pluginLib) {
    void* handle = dlopen(pluginLib.c_str(), RTLD_LAZY);
    if (handle == nullptr) {
        std::cerr << "Error loading plugin: " << dlerror() << std::endl;
        return nullptr;
    }

    dlerror();  // Clear any existing error

    createPlugin_t pluginFunc = (createPlugin_t) dlsym(handle, "createPlugin");

    const char* dlsym_error = dlerror();
    if (dlsym_error) {
        std::cerr << "Cannot load symbol createPlugin: " << dlsym_error << std::endl;
        dlclose(handle);
        return nullptr;
    }

    return pluginFunc();
}

int main(int argc, char** argv) {
    std::cout << "Launchin Plugin Architecture practice" << std::endl;

    // Read all .so files under the given directory and Load all plugins (run every one of them)
    std::string pluginDir = "/home/charly/Public/plugin_architecture_practice/lib";
    std::vector<std::thread> loadPluginThreads;
    for (const auto & entry : std::filesystem::directory_iterator(pluginDir)) {
        if (entry.path().extension() != ".so") continue;

        std::unique_ptr<PluginInterface> plugin = loadPlugin(entry.path().string());
        if (plugin == nullptr) {
            std::cerr << "Error loading plugin from " << entry.path().string() << std::endl;
            continue;
        }

        // Push the function object of to load the plugin
        std::cout << "Loading a plugin from " << entry.path().string() << std::endl;
        loadPluginThreads.emplace_back(std::thread([plugin = std::move(plugin)]() {
            plugin->run();
        }));
    }

    dlerror();  // Clear any existing error

    for (auto& thread : loadPluginThreads) {
        std::cout << "Joining thread" << std::endl;
        if (thread.joinable()) thread.join();
    }

    return EXIT_SUCCESS;
}
```

我們分解一下程式碼。先看主函式（程式進入點）：

```C++
std::string pluginDir = "/home/charly/Public/plugin_architecture_practice/lib";
std::vector<std::thread> loadPluginThreads;
for (const auto & entry : std::filesystem::directory_iterator(pluginDir)) {
    // Let assume all read in entry is a shared library

    std::unique_ptr<PluginInterface> plugin = loadPlugin(entry.path().string());

    // Push the function object of to load the plugin
    std::cout << "Loading a plugin from " << entry.path().string() << std::endl;
    loadPluginThreads.emplace_back(std::thread([plugin = std::move(plugin)]() {
        plugin->run();
    }));
}
```

在這一步，我們假設插件已經被建成對應的共享庫。在POSIX電腦中，共享庫的檔暗格式為.so。所以在上面的程式碼中，程序列出所有可以讀取的包含了類別和函數的可用共享庫。在for迴圈中，每個插件都會按名稱從共享庫中讀取，一旦插件被讀取並使用函數指標創建，插件類別的方法run()將作為其獨立的執行緒運行。

接著，我們來了解一下loadPlugin函數在做什麼。

```C++
std::unique_ptr<PluginInterface> loadPlugin(const std::string& pluginLib) {
    void* handle = dlopen(pluginLib.c_str(), RTLD_LAZY);
    if (handle == nullptr) {
        std::cerr << "Error loading plugin: " << dlerror() << std::endl;
        return nullptr;
    }

    dlerror();  // Clear any existing error

    createPlugin_t pluginFunc = (createPlugin_t) dlsym(handle, "createPlugin");

    const char* dlsym_error = dlerror();
    if (dlsym_error) {
        std::cerr << "Cannot load symbol createPlugin: " << dlsym_error << std::endl;
        dlclose(handle);
        return nullptr;
    }

    return pluginFunc();
}
```
涉及的步驟為下：

1. 創建一個指向共享庫的控制碼。由於程序不知道它所持有的記憶體的類型，我們將控制碼賦值為一個指向未確定類型的指標，也就是void*。RTLD_LAZY標誌表示動態符號的重定位（可以想像成這個指標物件指向的類別或函數）只有在需要的時後被呼叫，而不是一步到位。當實際需要時動態綁定符號可以提高實現的校能。所以，讓我們回顧一下達成這一步驟的程式碼：

```C++
void* handle = dlopen(pluginLib.c_str(), RTLD_LAZY);
```

不要忘記包含 `<dlfcn.h>` 以調用 `dlopen()` 函數！

1. 創建插件類別的函數指標。注意，在這個時候，你還差一步才能得到實際的插件物件。請使用下面的這一行創建：

```C++
createPlugin_t pluginFunc = (createPlugin_t) dlsym(handle, "createPlugin");
```

還記得這段程式碼嗎？

```C++
extern "C" {
    std::unique_ptr<PluginInterface> createPlugin() {
        return std::make_unique<Plugin1>();
    }
}
```
好像...更清楚它扮演的角色了。

3. 創建實際的插件指標實例：

```C++
return pluginFunc();
```

這將返回std::unique_ptr<PluginInterface>，這是一個用你想要在核心中加載的插件重載的基底類別指標。

如何讓插件運作？讓我們回到主函數：

```C++
std::unique_ptr<PluginInterface> plugin = loadPlugin(entry.path().string());

plugin->run();
```

這樣應該就可以讓外掛順利運行了。在實現主函數的時候，我們只是進一步把這個函數作為一個執行緒。最終，每個插件的線程都被創建，在結束的時候被連回煮函數所在的執行緒，或者說在主函數中劃下句點。

最後但同樣重要的，讓我們來看看如何使用 `CMakeLists.txt` 編譯所有這些東西。

我的項目檔案層次結構如下：

```
Plugin_architecture_practice/
├── CMakeLists.txt
├── applications
|   ├── CMakeLists.txt
|   ├── main.cpp
├── include/
|   ├── plugin_interface.h
|   ├── plugin_1/
|   |   ├── plugin_1.h
|   ├── plugin_2/
|       ├── plugin_2.h
├── src/
    ├── CMakeLists.txt
    ├── plugin_1/
    |   ├── CMakeLists.txt
    |   ├── plugin_1.cpp
    ├── plugin_2/
        ├── CMakeLists.txt
        ├── plugin_2.cpp
```

檔案結構看起來有點強大，但基本的想法是讓每個插件都被編譯成獨立的共享庫，然後再讓任何應用程序（主函數所在的地方）調用需要的插件。

首先，讓我們看看項目根目錄的CMakeLists。

**CMakeLists.txt**
```cmake
cmake_minimum_required(VERSION 3.2)

project(Plugin_Architecture_Practice)

set (CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "-Wall")
set(CMAKE_BUILD_TYPE Debug)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)

include_directories(include)

# Build plugins
add_subdirectory(src)

# Build applications
add_subdirectory(applications)
```

我偏好在專案中讓編譯出來的程式和函式庫能各居其所，所以你可以選擇是否要使用以下幾行指令：

```cmake
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)
```

現在，轉到個別外的 CMakeLists.txt。

```cmake
# Build a dynamic library
add_library(plugin_1 SHARED 
    plugin_1.cpp
)
```

在此，編譯後你會在你指定的目錄下找到一個libplugin_1.so 檔案。我的呢則在lib/路徑下。

現在是時候將插件庫加載到你選擇的應用程序中了。

```cmake
add_executable(${PROJECT_NAME}_node
    main.cpp
)
target_link_libraries( ${PROJECT_NAME}_node
    plugin_1
)
```

就是這樣！第一次編譯專案時，你需要使用以下命令：

```bash
$ mkdir build
$ cd build
$ cmake ..
$ make
```

對於後續的編譯，你只需要__cd__到你的build/目錄並輸入命令 `make`。

# 總結

這就是全部內容！恭喜！你剛剛學會了如何用現代C++的方式實現插件架構。但其實還有一些可改進之處。

## 其實...還能更好

在實現涉及操作動態記憶體的程序時，使用C和C++的一個缺點是，我們仍然需要使用C風格的指標，如void*的情況，如果沒有適當的垃圾回收處理，可能會導致不易察覺的內存洩漏。不幸的是，C/C++不會明確地告訴你是否有任何需要提前排除的問題或隱憂，這得交給開發者來負責處理操作和釋放記憶體的每一個可能的途徑。

說到釋放記憶體，這段程式碼中顯然有一個問題。你還記得我們使用`dlopen()`返回了一個__void*__指標嗎？在我們這個範例中，程序從未使用`dclose(handle)`來釋放指標。這個問題交給開發者來解決。

此外，通過操作動態記憶體，使用如__Valgrind__這樣的工具對記憶體使用情況進行分析時，即使資源可能早已被釋放，還是有可能會顯示存在內存洩漏。但在這個案例中，我們還沒有做dclose()，所以在這段提出的問題跟我們無關。

同樣地，儘管使用智慧指標來包裝從`dlsym()`返回的函數指標，仍有可能產生內存洩漏。解決這個問題需要採取並不怎麼直觀的解決手段來減輕、解決或是繞過問題。我個人認為無論哪種手段都很醜陋。

就算如此，我還是認為這就是程式設計的樂趣之一...我希望這篇文章能幫助你，如果你想自己實現一個外掛程式架構。請靜下心來多多練習。祝安康！

# 參考資料

- [Joydip Kanjilal - Why do we Need Virtual Destructors? - LinkedIn](https://www.linkedin.com/pulse/why-do-we-need-virtual-destructors-joydip-kanjilal)

- [How To Create a Flexible Plug-In Architecture? - StackOverflow](https://stackoverflow.com/questions/2768104/how-to-create-a-flexible-plug-in-architecture)

- [Omar Elgabry - Plug-in Architecture - Medium](https://medium.com/omarelgabrys-blog/plug-in-architecture-dec207291800)

- [Plugin Architecure - retrieved file type: PDF](https://cs.uwaterloo.ca/~m2nagapp/courses/CS446/1195/Arch_Design_Activity/PlugIn.pdf)

- [Joseph Gefroh - How to Design Software — Plugin Systems - Medium](https://betterprogramming.pub/how-to-design-software-plugins-d051ce1099b2)

- [ahota/zoo: An example C++ plugin architecture with on-the-fly plugin inclusion  - GitHub](https://github.com/ahota/zoo)